---
layout: post
title: "Should that be a Microservice? Keep These Six Factors in Mind"
date: 2018-06-09 00:02:05 +0900
tag: Article
---

당신은 그 어느 때보다도 많은 코드를 쓰고 있다. 이 트릭은 무엇이 마이크로서비스가 되어야 하는지, 말아야 하는지 아는것이다.
요즘 마이크로 서비스는 몹시 뜨겁다. 개발자들은 에릭 에반의 책 도메인 주도 개발을 공부하고, 개발팀은 기존의 monolithic 앱들을 리팩토링하며, 바운디드 컨텍스트들을 찾고, 유비쿼터스 랭귀지를 정의한다.
또한, 마이크로 서비스로 전환하는데 도움이 되는 수많은 아티클, 동영상, 자문을 구하지만, 주어진 어플리케이션이 마이크로 서비스가 되어야 하는지 본질적인 고민을 하는 사람은 거의 없다.
마이크로 서비스 아키텍쳐를 사용했을때 얻을 수 있는 이점은 많다. 하지만 세상에 공짜는 없듯이, 마이크로 서비스의 도입은 복잡성을 증가시킨다. 그럼에도 개발팀은 마이크로 서비스가 가져다 주는 장점을 위해 그 복잡성을 기꺼이 받아들여야 한다.

### 책임감있게 마이크로서비스를 사용해라.

Matt Stine와 나는 요즘 고객들의 어플리케이션을 보면서 시간을 보냈다. 토론은 요즘 자주 들리는 "모든 시스템은 마이크로서비스로 되어야 한다." 에서 시작되었다. 사람들이 다양한 구현 세부 사항을 놓고 논쟁을 벌이는 가운데 대화는 중단되었다.
그로인해 Matt는 화이트보드에 몇가지 원칙을 적기 시작했다. 이 간단한 원칙은 논쟁을 끝으로 이끌었다. 우리는 그들에게 마이크로 서비스가 가치를 제공할 수 있는 부분을 찾기 위해 어플리케이션의 아키텍처에 모든 부분에 대하여 질문하였다. 이 원칙들은 근본적으로 대화의 어조를 바꾸었고, 개발팀이 좋은 아키텍처를 설계하는데 도움이 되었다.
잉여 마이크로 서비스의 세계를 없애기 위해, 우리는 여러분들의 마이크로 서비스로 전환에 들이는 노력을 돕기위해 이 원칙을 발표한다. 다음 원칙을 읽고 여러분의 어플리케이션이 해당 원칙을 충족하는지 확인해봐라.
다음 원칙 중 하나 이상에 대해 "예" 라고 대답하는 경우, 마이크로 서비스가 되기에 적합하다. 모든 원칙에 대하여 "아니요"라고 대답할 경우 시스템에 불필요한 복잡성을 도입할 뿐일 가능성이 높을것이다.

### 1. 많은 변경 빈도

시스템의 일부가 다른 속도로 발전하거나, 다른 방향으로 발전해야 하는가? 그렇다면 그 부분을 마이크로 서비스로 변경해라. 마이크로 서비스는 각각의 컴포넌트들이 독립적인 라이프 사이클을 가지게 할 수 있다.
어떤 시스템에도 일부 모듈은 거의 변하지 않고, 다른 모듈은 매번 변경되는것처럼 보인다. 예를들면 온라인 쇼핑몰 앱을 예로 들어보자.

![image1](https://content.cdntwrk.com/files/aHViPTYzOTc1JmNtZD1pdGVtZWRpdG9yaW1hZ2UmZmlsZW5hbWU9aXRlbWVkaXRvcmltYWdlXzVhNjEzZDRiOGU1ZGMucG5nJnZlcnNpb249MDAwMCZzaWc9MWY0NTVkZmIzOWY3N2E3YTQ5MzhiN2YwYWQxNmI2YzQ%253D)

카트와 인벤토리 기능은 일상적인 자주 변경되지 않을 수 있다. 하지만 우리는 끊임없이 추천 엔진을 실험하고 있을 것이다. 또한 검색 기능을 부지런히 개선하고자 한다. 이 두 모듈을 마이크로서비스로 나누면 각 개발팀이 더 빠른 속도로 개발 사이클을 수행하여 비즈니스 가치를 신속하게 제공 할 수 있다.

![image2](https://content.cdntwrk.com/files/aHViPTYzOTc1JmNtZD1pdGVtZWRpdG9yaW1hZ2UmZmlsZW5hbWU9aXRlbWVkaXRvcmltYWdlXzVhNjEzZDcxMTcxMWQucG5nJnZlcnNpb249MDAwMCZzaWc9MDA0NGNjYWFhMTU1Yzc4NDBhMGY3YzNjNzI5NDM1YmE%253D)

### 2. 독립적인 라이프사이클

모듈이 완전히 독립적인 라이프 사이클(코드를 커밋하는 순간부터 프로덕트에 반영되기 까지의 흐름)을 가져야 하는 경우에는 마이크로서비스여야 한다. 이를위해 자체 코드 저장소와, CI/CD 파이프라인등을 갖추고 있어야 한다. 범위가 작으면 마이크로 서비스를 테스트 하는 것이 훨씬 쉬워진다. 나는 80시간에 이르는 회귀 테스트를 가진 프로젝트를 기억한다. 말할 필요도 없이 우리는 필요하지만, 그 테스트를 자주 수행하지 않았다. 마이크로서비스는 작은 규모의 회귀 테스트를 가능케 한다. 이렇게 하면 수없이 많은 시간을 절약할수 있고, 더 빨리 이슈를 깨나갈 것이다. 마이크로서비스를 도입해야 할 이유가 테스트에만 있는것은 아니다. 어떤 경우에는 비즈니스 요구사항이 마이크로 서비스 아키텍처로 우리를 이끌 수 있다. 아까 언급했던 쇼핑몰 Widget.io 를 보자.

우리의 비즈니스 리더쉽은 새로운 기회를 포작했을 수 있고, 이때는 빠르게 시장을 점유하는것이 가장 중요하다. 우리가 새로운 기능을 기존의 monolithic 한 서비스에 추가하기로 결정한다면 너무 오래 걸릴것이다. 그렇다는것은 곧 우리는 비즈니스가 요구하는대로 반응할 수 없다는 것을 의미한다.

그러나 독립적인 마이크로서비스로서 프로젝트X는 자체 배포 파이프라인을 가질 수 있다. 이 접근법을 통해 우리는 신속하게 개발 사이클을 반복하고, 새로운 비즈니스 기회를 활용할 수 있다.

![image3](https://content.cdntwrk.com/files/aHViPTYzOTc1JmNtZD1pdGVtZWRpdG9yaW1hZ2UmZmlsZW5hbWU9aXRlbWVkaXRvcmltYWdlXzVhNjEzZDhjOGMwMDkucG5nJnZlcnNpb249MDAwMCZzaWc9MjMzNzk3ZDQ0ZWMxMDAzMmZlMDgwZGY3YjZlM2E1OTI%253D)

### 3. 독립적인 확장성(Scalability)

시스템의 일부분이 부하나 처리량이 다를 경우, 스케일링에 있어 요구사항이 다를 수 있는데 이 부분을 마이크로 서비스로 분리하여 해결할 수 있다.

일반적인 아키텍처에서도 모듈간 다른 스케일링을 요구하는 경우는 빈번하다. 앞서 예로 들었던 쇼핑몰 Widget.io 를 보자.
회계 관리 기능에 가해지는 부하는 주문 처리 기능에 비하면 몹시 적다. 과거에는 이런 주문 처리 기능처럼 몰리는 모듈을 위해 전체 어플리케이션을 확장해야만 했다. 이러한 방법은 인프라 비용을 증가시키는 결과를 낳는다. 앱의 일부 부하가 몰리는 부분으로 인해 그렇지 않은 부분까지 확장해야 하기 때문이다.

만약 주문 처리 기능을 마이크로 서비스로 리팩토링한다면 필요에 따라 다음과 가이 확장할 수 있게 된다.
![image3](https://content.cdntwrk.com/files/aHViPTYzOTc1JmNtZD1pdGVtZWRpdG9yaW1hZ2UmZmlsZW5hbWU9aXRlbWVkaXRvcmltYWdlXzVhNjEzZGEwYTg1MjcucG5nJnZlcnNpb249MDAwMCZzaWc9MzkyOWE1ZGM2OWZlMjA3MWE5NmQ4YTJjOWE3ZTdiZjM%253D)

### 4. 장애의 고립

때로는 특정 타입의 장애로부터 앱을 격리시키고자 한다. 예를들어 의존하고 있는 외부 서비스가 가용성 목표를 충족하지 못할 때 어떤 일이 발생될까? 우리는 그 의존성을 나머지 시스템들과 분리하기 위해 마이크로 서비스를 만들어 그 서비스에 적절한 페일오버 메커니즘을 구축 할 수 있다

다시한번 Widget.io 로 돌아가면, 재고 기능은 레거시인 창고 시스템과 상호작용 한다. 이때, 인벤토리 모듈을 마이크로 서비스로 리팩토링 하여 서비스의 가용성 목표를 충족시킬 수 있다. 창고 시스템의 불안정성을 설명하기 위하여 불필요한 중복을 더할 수 있다? 우리는 또한 인벤토리를 레디스에 캐시해 두는것과 같이 항상 정합성을 유지하기 위한 메커니즘을 도입할 수도 있다.
![image4](https://content.cdntwrk.com/files/aHViPTYzOTc1JmNtZD1pdGVtZWRpdG9yaW1hZ2UmZmlsZW5hbWU9aXRlbWVkaXRvcmltYWdlXzVhNjEzZGIyMGZhN2YucG5nJnZlcnNpb249MDAwMCZzaWc9NGNiNmVkZjc1MmZmY2FmMmJiYWMwODc2YzM2N2Q3MGI%253D)

### 5. 외부 종속성과의 인터랙션 단순화 (Facade 패턴)

이번 원칙은 앞서 얘기했던 `장애의 고립` 원칙과 비슷하다. 이 원칙은 외부의 의존성으로부터 시스템을 보호하는데 더 초점을 맞춘다. 마이크로서비스는 간접적인 계층으로 동작하여, 써드파티로부터 우리의 시스템을 격리시킬 수 있다.
의존성을 직접적으로 호출하는 대신 핵심 앱과 의존성 사이에 추상화 계층(우리가 통제하는)을 배치할 수 있다. 또한 우리는 이 계층을 만들어서 응용프로그램이 쉽게 소비되도록 하고, 의존성의 복잡성을 숨길 수 있다.
미래에 상황이 바뀌고 마이그레이션해야하는 경우 변경 사항은 더 큰 리팩토링이 아닌 추상화된 계층만 마이그레이션 하면 된다.

### 6. 기술선택의 자유로움

마이크로서비스로 팀은 선호하는 기술 스택을 자유롭게 사용할 수 있다. 요구사항에 가장 적합한 기술 스택을 채택하거나, 개발자가 익숙하고 잘하는 스택을 자유롭게 채택할 수 있게 된다. 너무 다양한 개발스택은 오버헤드를 추가하고, 오히려 단일 개발스택보다
더 단점이 많을 수 있다.

### 조직의 문화를 점검해라

기술적인 이야기를 하다가 갑자기 왜 문화를 논하는지 궁금한가? 기술적인 결정이 하늘에서 갑자기 뚝 떨어지진 않는다. 그렇기 때문에 마이크로서비스의 멋진 세계로 뛰어들기 전에 당신의 조직을 한번 점검해봐라.
조직의 구조가 마이크로서비스 아키텍처를 적용하기에 지원하는가? [콘웨이의 법칙](http://www.melconway.com/Home/Conways_Law.html)은 당신의 성공 가능성에 대하여 어떻게 얘기하는가?

50년 전 멜 콘웨이는 어떤 조직이 설계한 시스템이 조직도를 반영하는 시스템을 만들 것이라고 이론화했다. 즉, 팀이 소규모의 자율적인 그룹으로 조직되지 않으면 엔지니어는 소규모의 자율적인 서비스로 구성된 소프트웨어를 만들지 않을 거라는걸 의미한다.
이를 통해 팀은 그들의 소프트웨어에 적용하고 싶은 아키텍처에 대응되는 팀을 만들기 위해 조직도를 변경했다.

또한 당신은 당신 스스로가 얼마나 문화를 받아들일 준비가 되었는지도 고려해야 한다. 마이크로서비스는 작고 빈번한 변경을 장려하는데 이런 리듬은 기존의 분기별로 배포하던 배포사이클과 어긋난다.
마이크로서비스로는 코드 동결이나 ‘빅뱅’ 코드 통합이 이루어지지 않는다. 마이크로서비스 기반의 아키텍처는 전통적인 워터폴 개발방식 환경에서도 확실히 작동할 수 있지만, 완전한 이점을 보지는 못할 것이다.

이후 PCF 광고.
